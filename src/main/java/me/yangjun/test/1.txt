http://distro.ibiblio.org/

使用sbt构建web项目
http://blog.csdn.net/gabriel_2/article/details/37915399


端口
所有：netstat -ano
查找：netstat -ano|findstr "8080"
tasklist|findstr "13244"


快捷键：
	alt + shift + p ：实现抽象方法

多行标签：
	右键标签 --> Tabs Placement --> 取消勾选Show Tabs Single Row

Spark大数据处理：技术、应用与性能优化
Java与模式

POJO的格式是用于数据的临时传递，它只能装载数据， 作为数据存储的载体，而不具有业务逻辑处理的能力。
JavaBean虽然数据的获取与POJO一样，但是JavaBean当中可以有其它的方法。


如果是加包名的话步骤如下：

1、右键项目名，点击New；
2、选择Package，在弹出的对话框中选择加包的位置（Source folder）和输入包名（Name）；
3、之后点击Finish就完成了。

如果是添加jar包的话，步骤如下：
1、在项目中添加一个文件夹名字叫lib；
2、之后把要加入的jar包复制到该文件夹下；
3、然后右击这个jar文件，选择Build Path；
4、再选择Add to Build Path，就完成了。


值传递和引用传递
String，StringBuffer，StringBuild区别

多线程、集合、枚举、反射、单例模式、类加载顺序、抽象类和接口、多态、重写和覆盖


mkdir 新目录名
rm 待删除的文件名/目录名
mv 老地址 新地址
cp 老文件名 新文件名
cat/more 文件名（显示文件内容，一个不分页，一个分页）




-- CONCAT_WS函数
mysql> SELECT CONCAT_WS("," , "First name" , "Second name" , "Last Name") FROM DUAL;
       -> 'First name,Second name,Last Name'
mysql> SELECT CONCAT_WS("," , "First name" , NULL , "Last Name") FROM DUAL;
       -> 'First name,Last Name'

-- COUNT函数 count一个null字段的时候结果为0
mysql> SELECT COUNT(1) FROM TEST WHERE NAME IS NULL;
       -> 7
mysql> SELECT COUNT(NAME) FROM TEST WHERE NAME IS NULL;
       -> 0
	   
-- bigint类型的字段取值到int类型的字段的时候，如果取出来的值大于int的最大值，就会发生溢出，变成一个负数

-- Oracle where 从右往左解析 Mysql 从左往右解析

-- union all   join   开窗函数   关联更新


在不使用spring框架之前，我们的service层中要使用dao层的对象，不得不在service层中new一个对象。如下：

//dao层对象
public class UserDao{
   public void insert(User user){}
}
 
//service层对象
public classUserService{
   public void insert(User user){
       UserDao userdao = new UserDao();
       userdao.insert(user);
   }
}



存在的问题：层与层之间的依赖。

使用框架后：


//dao层对象
public class UserDao{
    public void insert(User user){}
}
 
//service层对象
public classUserService{
   private UserDao userdao;
 
   public UserDao getUserdao() {
      return userdao;
   }
   public void setUserdao(UserDao userdao) {
      this.userdao= userdao;
   }
 
   public void insert(User user){
      userdao.insert(user);
   }
 
}


service层要用dao层对象需要配置到xml配置文件中，至于对象是怎么创建的，关系是怎么组合的都交给了spring框架去实现。





创建一个类继承自Comparable接口
创建一个比较器实现Comparator接口
集合类相关的线程问题









Spark大数据处理：技术、应用与性能优化
Java与模式

POJO的格式是用于数据的临时传递，它只能装载数据， 作为数据存储的载体，而不具有业务逻辑处理的能力。
JavaBean虽然数据的获取与POJO一样，但是JavaBean当中可以有其它的方法。


如果是加包名的话步骤如下：

1、右键项目名，点击New；
2、选择Package，在弹出的对话框中选择加包的位置（Source folder）和输入包名（Name）；
3、之后点击Finish就完成了。

如果是添加jar包的话，步骤如下：
1、在项目中添加一个文件夹名字叫lib；
2、之后把要加入的jar包复制到该文件夹下；
3、然后右击这个jar文件，选择Build Path；
4、再选择Add to Build Path，就完成了。


值传递和引用传递
String，StringBuffer，StringBuild区别

多线程、集合、反射、单例模式、类加载顺序、抽象类、多态、重写和覆盖、异常、内部类

枚举
所有的枚举值都是类静态常量

接口
接口中的变量默认拥有是 public static final 属性

集合类
Collection--
    		List----
					ArrayList
			Set-----
					HashSet
					TreeSet
Map---------
			HashMap
			TreeMap


总述：List、Set、Map是这个集合体系中最主要的三个接口。
其中List和Set继承自Collection接口。
Set不允许元素重复。HashSet和TreeSet是两个主要的实现类。
List有序且允许元素重复。ArrayList、LinkedList和Vector是三个主要的实现类。
Map也属于集合系统，但和Collection接口不同。Map是key对value的映射集合，其中key列就是一个集合。
	key不能重复，但是value可以重复。HashMap、TreeMap和Hashtable是三个主要的实现类。
SortedSet和SortedMap接口对元素按指定规则排序，SortedMap是对key列进行排序。



具体来说：
1.Collection 接口用于表示任何对象或元素组。想要尽可能以常规方式处理一组元素时，就使用这一接口。
操作：

(1) 单元素添加、删除操作：
boolean add(Object o):将对象添加给集合
boolean remove(Object o): 如果集合中有与o相匹配的对象，则删除对象o

(2) 查询操作：
int size() ：返回当前集合中元素的数量
boolean isEmpty() ：判断集合中是否有任何元素
boolean contains(Object o) ：查找集合中是否含有对象o
Iterator iterator() ：返回一个迭代器，用来访问集合中的各个元素

(3) 组操作 ：作用于元素组或整个集合
boolean containsAll(Collection c): 查找集合中是否含有集合c 中所有元素
boolean addAll(Collection c) : 将集合c 中所有元素添加给该集合
void clear(): 删除集合中所有元素
void removeAll(Collection c) : 从集合中删除集合c 中的所有元素
void retainAll(Collection c) : 从集合中删除集合c 中不包含的元素

(4) Collection转换为Object数组 ：
Object[] toArray() ：返回一个内含集合所有元素的array
Object[] toArray(Object[] a) ：返回一个内含集合所有元素的array。运行期返回的array和参数a的型别相同，需要转换为正确型别。

不能直接把集合转换成基本数据类型的数组，因为集合必须持有对象。

Collection是无序的，不提供get()方法。如果要遍历Collectin中的元素，就必须用Iterator。



2.List接口对Collection进行了简单的扩充，它的具体实现类常用的有ArrayList和LinkedList。你可以将任何东西放到一个 List容器中，并在需要时从中取出。ArrayList从其命名中可以看出它是一种类似数组的形式进行存储，因此它的随机访问速度极快，而 LinkedList的内部实现是链表，它适合于在链表中间需要频繁进行插入和删除操作。在具体应用时可以根据需要自由选择。前面说的Iterator只 能对容器进行向前遍历，而ListIterator则继承了Iterator的思想，并提供了对List进行双向遍历的方法。
(1) 面向位置的操作包括插入某个元素或 Collection 的功能，还包括获取、除去或更改元素的功能。在 List 中搜索元素可以从列表的头部或尾部开始，如果找到元素，还将报告元素所在的位置 :

void add(int index, Object element): 在指定位置index上添加元素element
boolean addAll(int index, Collection c): 将集合c的所有元素添加到指定位置index
Object get(int index): 返回List中指定位置的元素
int indexOf(Object o): 返回第一个出现元素o的位置，否则返回-1
int lastIndexOf(Object o) ：返回最后一个出现元素o的位置，否则返回-1
Object remove(int index)　：删除指定位置上的元素
Object set(int index, Object element) ：用元素element取代位置index上的元素，并且返回旧的元素

(2) List 接口不但以位置序列迭代的遍历整个列表，还能处理集合的子集：
ListIterator listIterator() : 返回一个列表迭代器，用来访问列表中的元素
ListIterator listIterator(int index) : 返回一个列表迭代器，用来从指定位置index开始访问列表中的元素
List subList(int fromIndex, int toIndex) ：返回从指定位置fromIndex（包含）到toIndex（不包含）范围中各个元素的列表视图
“对子列表的更改（如 add()、remove() 和 set() 调用）对底层 List 也有影响。” “ArrayList 和 LinkedList 都实现 Cloneable 接口，都提供了两个构造函数，一个无参的，一个接受另一个Collection”



LinkedList类

LinkedList类添加了一些处理列表两端元素的方法。
(1) void addFirst(Object o): 将对象o添加到列表的开头
void addLast(Object o)：将对象o添加到列表的结尾
(2) Object getFirst(): 返回列表开头的元素
Object getLast(): 返回列表结尾的元素
(3) Object removeFirst(): 删除并且返回列表开头的元素
Object removeLast():删除并且返回列表结尾的元素
(4) LinkedList(): 构建一个空的链接列表
LinkedList(Collection c): 构建一个链接列表，并且添加集合c的所有元素
“使用这些新方法，您就可以轻松的把 LinkedList 当作一个堆栈、队列或其它面向端点的数据结构。”



ArrayList类
ArrayList类封装了一个动态再分配的Object[]数组。每个ArrayList对象有一个capacity。这个capacity表示存储列表中元素的数组的容量。当元素添加到ArrayList时，它的capacity在常量时间内自动增加。

在向一个ArrayList对象添加大量元素的程序中，可使用ensureCapacity方法增加capacity。这可以减少增加重分配的数量。
(1) void ensureCapacity(int minCapacity): 将ArrayList对象容量增加minCapacity
(2) void trimToSize(): 整理ArrayList对象容量为列表当前大小。程序可使用这个操作减少ArrayList对象存储空间。








Head First Java
字符串为null或者“”
if (str != null && str.length() != 0)

code point
code util

length：
数组是属性
字符串是方法


StringBuilder => String   :toString()
StringBuffer 多线程
StringBuilder 和 StringBuffer 的API相同

Scanner in = new Scanner(System.in); 
//Scanner in = new Scanner(Paths.get("myfile.txt"));
//Scanner in = new Scanner(Paths.get("c:\\mydirectory\\myfile.txt"));
String name = in.nextLine();
PrintWrite out = new PrintWrite("myFile.txt");

https://segmentfault.com/a/1190000007225325
http://dongxicheng.org/about/